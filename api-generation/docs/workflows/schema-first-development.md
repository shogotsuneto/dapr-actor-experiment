# Schema-First Development Workflow

A minimal demo of Dapr actors application in Go, demonstrating actor state management and method invocation patterns with schema-first development.

> **Note**: This documentation was largely generated by AI to provide comprehensive examples and explanations.

This document demonstrates the complete workflow for schema-first development using OpenAPI 3.0 (the only currently implemented schema format).

## Overview

Schema-first development reverses the traditional approach:
- **Traditional**: Code → API Documentation
- **Schema-First**: API Schema → Code Implementation

## Benefits

1. **Consistency**: Implementation must match the schema
2. **Type Safety**: Generated types prevent runtime errors
3. **Documentation**: Schema serves as authoritative documentation
4. **Validation**: Automatic request/response validation
5. **Interface Generation**: Schema-enforced implementation interfaces

## Complete Example: Counter Actor

### Step 1: Define the API Schema

Create an OpenAPI specification:

```yaml
# api-generation/schemas/openapi/multi-actors.yaml
openapi: 3.0.3
info:
  title: CounterActor API
  version: 1.0.0
paths:
  /{actorId}/method/increment:
    post:
      operationId: incrementCounter
      parameters:
        - name: actorId
          in: path
          required: true
          schema:
            type: string
      responses:
        '200':
          content:
            application/json:
              schema:
                $ref: '#/components/schemas/CounterState'
```

### Step 2: Generate Code from Schema

```bash
cd api-generation
./tools/scripts/generate.sh openapi schemas/openapi/multi-actors.yaml
```

This generates type definitions and schema interface in `../internal/generated/openapi/`.

### Step 3: Implement Against Schema

```go
// internal/actor/counter.go
package actor

import "github.com/shogotsuneto/dapr-actor-experiment/internal/generated/openapi"

type CounterActor struct {
    actor.ServerImplBaseCtx
}

// Implementation must use generated types
func (c *CounterActor) Increment(ctx context.Context) (*openapi.CounterState, error) {
    // Schema-compliant implementation
    state, err := c.getState(ctx)
    if err != nil {
        return nil, err
    }
    state.Value++
    return state, c.setState(ctx, state)
}
```

### Step 4: Validate Implementation

The generated types ensure compile-time schema compliance:

```go
// This won't compile if the schema changes
var state *openapi.CounterState = actor.Increment(ctx)

// Request validation is built into the generated types
request := openapi.SetValueRequest{Value: 42} // Type-safe
```

## Best Practices

### Schema Design
- Start with operations: Define what your API does
- Design for evolution: Use versioning and optional fields
- Document everything: Include descriptions and examples
- Validate early: Use schema validation in CI/CD

### Implementation
- Use generated types: Don't create parallel type definitions
- Validate inputs: Use schema-defined validation rules
- Handle errors: Map to schema-defined error formats
- Log schema info: Include schema version in logs

### Testing
- Test schema compliance: Ensure implementation matches schema
- Test edge cases: Validate boundary conditions defined in schema
- Integration tests: Test full request/response cycle

## Resources

- [OpenAPI Specification](https://swagger.io/specification/)
- [Dapr Actors Documentation](https://docs.dapr.io/developing-applications/building-blocks/actors/)

This workflow demonstrates how to implement schema-first development, ensuring that your implementation always matches your API specification.