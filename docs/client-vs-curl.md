# Client vs Curl: Understanding the Difference

> **Note**: This documentation was largely generated by AI to provide comprehensive comparison and examples.

## Overview

This demo provides **two different ways** to interact with Dapr actors:

1. **Go Client** (`cmd/client/main.go`) - Uses Dapr Go SDK
2. **Curl Commands** (`scripts/test-actor.sh`) - Raw HTTP calls

Both ultimately send **HTTP requests** to the Dapr sidecar, but they differ in how they construct and send those requests.

## Go Client Approach

### How It Works

```go
// cmd/client/main.go
c, err := client.NewClient()  // Creates Dapr SDK client

// Invoke actor method
result, err := c.InvokeActor(ctx, &client.InvokeActorRequest{
    ActorType: "CounterActor",
    ActorID:   "counter-1", 
    Method:    "increment",
    Data:      nil,
})
```

### What Happens Under the Hood

1. **Dapr SDK** creates HTTP client pointing to Dapr sidecar (localhost:3500)
2. **SDK constructs** proper HTTP request:
   ```
   POST http://localhost:3500/v1.0/actors/CounterActor/counter-1/method/increment
   Content-Type: application/json
   ```
3. **SDK handles** serialization/deserialization automatically
4. **Error handling** and retries managed by SDK

### Generated HTTP Request

The Go client ultimately generates this HTTP request:
```http
POST /v1.0/actors/CounterActor/counter-1/method/increment HTTP/1.1
Host: localhost:3500
Content-Type: application/json
User-Agent: dapr-sdk-go/1.x.x

{}
```

## Curl Approach

### How It Works

```bash
# scripts/test-actor.sh
curl -X POST \
  "http://localhost:3500/v1.0/actors/CounterActor/counter-1/method/increment" \
  -H "Content-Type: application/json" \
  -d '{}'
```

### Direct HTTP Request

This sends **exactly the same HTTP request** as the Go client:
```http
POST /v1.0/actors/CounterActor/counter-1/method/increment HTTP/1.1
Host: localhost:3500
Content-Type: application/json
User-Agent: curl/7.x.x

{}
```

## Detailed Comparison

### Request Construction

**Go Client:**
```go
// High-level, type-safe API
req := &client.InvokeActorRequest{
    ActorType: "CounterActor",
    ActorID:   "counter-1",
    Method:    "set",
    Data:      []byte(`{"value": 42}`),  // JSON payload
}
result, err := c.InvokeActor(ctx, req)
```

**Curl:**
```bash
# Manual URL construction and JSON formatting
curl -X POST \
  "http://localhost:3500/v1.0/actors/CounterActor/counter-1/method/set" \
  -H "Content-Type: application/json" \
  -d '{"value": 42}'  # Raw JSON string
```

### Error Handling

**Go Client:**
```go
result, err := c.InvokeActor(ctx, req)
if err != nil {
    // Structured error from SDK
    log.Printf("Actor invocation failed: %v", err)
    return
}

// Automatic JSON parsing
var response CounterResponse
if err := json.Unmarshal(result.Data, &response); err != nil {
    log.Printf("Failed to parse response: %v", err)
    return
}
```

**Curl:**
```bash
# Manual error checking via exit codes and response parsing
response=$(curl -s -w "%{http_code}" -X POST \
  "http://localhost:3500/v1.0/actors/CounterActor/counter-1/method/increment")

http_code="${response: -3}"
if [ "$http_code" != "200" ]; then
    echo "HTTP error: $http_code"
    exit 1
fi

# Manual JSON parsing with jq
value=$(echo "$response" | head -c -4 | jq -r '.value')
```

### Response Handling

**Go Client - Structured:**
```go
type CounterResponse struct {
    Value int `json:"value"`
}

var response CounterResponse
json.Unmarshal(result.Data, &response)
fmt.Printf("Counter value: %d\n", response.Value)
```

**Curl - String Processing:**
```bash
# JSON response as text, requires parsing
response='{"value": 42}'
value=$(echo "$response" | jq -r '.value')
echo "Counter value: $value"
```

## Advantages and Use Cases

### Go Client Advantages

✅ **Type Safety**: Compile-time checking of request structure  
✅ **Error Handling**: Structured error types and automatic retries  
✅ **Productivity**: Less boilerplate code  
✅ **Integration**: Natural fit in Go applications  
✅ **Debugging**: Better stack traces and logging  
✅ **Testing**: Easy to mock and unit test  

**Best for:**
- Production applications
- Integration with larger Go services
- Complex actor interactions
- Automated testing suites

### Curl Advantages

✅ **Simplicity**: No dependencies or compilation  
✅ **Debugging**: Easy to see exact HTTP traffic  
✅ **Scripting**: Simple bash automation  
✅ **Learning**: Understand the underlying protocol  
✅ **Cross-Language**: Works from any environment  
✅ **Quick Testing**: Fast iteration during development  

**Best for:**
- Quick testing and experimentation
- Shell scripts and automation
- Debugging HTTP-level issues
- Understanding Dapr API structure
- CI/CD health checks

## Network Traffic Comparison

Both approaches generate **identical network traffic**:

### Successful Increment Request
```http
→ POST /v1.0/actors/CounterActor/counter-1/method/increment
   Host: localhost:3500
   Content-Type: application/json
   
   {}

← HTTP/1.1 200 OK
   Content-Type: application/json
   
   {"value": 1}
```

### Set Value Request
```http
→ POST /v1.0/actors/CounterActor/counter-1/method/set
   Host: localhost:3500
   Content-Type: application/json
   
   {"value": 42}

← HTTP/1.1 200 OK
   Content-Type: application/json
   
   {"value": 42}
```

## Performance Comparison

| Aspect | Go Client | Curl |
|--------|-----------|------|
| **Latency** | ~1-2ms overhead | ~1-2ms overhead |
| **Throughput** | High (connection reuse) | Lower (new process per call) |
| **Memory** | Low (single process) | Higher (fork/exec overhead) |
| **CPU** | Efficient | Process creation cost |

*Both have similar network latency since they use the same HTTP protocol*

## When to Use Which?

### Use Go Client When:
- Building production Go applications
- Need type safety and error handling
- Integrating with existing Go services
- Writing automated tests
- Performance is critical

### Use Curl When:
- Quick testing during development
- Writing shell scripts or CI/CD checks
- Learning the Dapr actor API
- Debugging HTTP-level issues
- Working from non-Go environments

## Summary

**The Go client and curl are doing exactly the same thing** - sending HTTP requests to the Dapr sidecar. The difference is:

- **Go Client**: High-level, type-safe wrapper around HTTP calls
- **Curl**: Direct, manual HTTP requests

Choose based on your use case: Go client for applications, curl for testing and scripts. Both are valuable tools in the Dapr actor development workflow.