# Event Sourcing in Dapr Actors

> **Note**: This documentation was generated by AI to provide comprehensive explanation and examples.

## Does This Implementation Use Event Sourcing?

**No, this implementation does NOT use event sourcing.** This is a **state-based** actor implementation.

## Understanding the Difference

### What This Implementation Does (State-Based)

```go
// Current implementation - stores current state only
type CounterState struct {
    Value int `json:"value"`
}

// When increment is called:
// 1. Load current state: {value: 5}
// 2. Modify state: {value: 6} 
// 3. Save new state: {value: 6}
// 4. Previous state {value: 5} is lost
```

**Characteristics:**
- Stores only the **current state** of the actor
- Each operation **overwrites** the previous state
- No history of what happened - only "what is"
- Simple and efficient for most use cases
- State is stored in Redis as a single JSON document

### What Event Sourcing Would Look Like

```go
// Event sourcing approach - stores sequence of events
type CounterEvent struct {
    Type      string    `json:"type"`      // "incremented", "decremented", "set"
    Value     int       `json:"value"`     // the change amount or new value
    Timestamp time.Time `json:"timestamp"`
    EventID   string    `json:"eventId"`
}

// When increment is called:
// 1. Append new event: {type: "incremented", value: 1, timestamp: now}
// 2. Current state is computed by replaying ALL events
// 3. All historical events are preserved
```

**Characteristics:**
- Stores **sequence of events** that led to current state
- Current state is **computed** by replaying events
- Complete **audit trail** of all changes
- Can reconstruct state at any point in time
- More complex but provides full history

## Why State-Based Was Chosen

1. **Simplicity**: Easier to understand and implement
2. **Performance**: Direct state access without event replay
3. **Storage Efficiency**: Single document vs. potentially thousands of events
4. **Use Case Fit**: Simple counter doesn't need historical tracking

## When to Use Event Sourcing

Consider event sourcing when you need:

- **Audit Trail**: Track all changes for compliance/debugging
- **Time Travel**: Reconstruct state at any point in history  
- **Complex Business Logic**: Multiple aggregates that need to react to events
- **Analytical Queries**: Answer questions about what happened when
- **Compensating Actions**: Ability to undo operations

## Example: Converting to Event Sourcing

If you wanted to add event sourcing to this demo:

```go
// 1. Define events
type CounterIncremented struct {
    Amount    int       `json:"amount"`
    Timestamp time.Time `json:"timestamp"`
}

type CounterSet struct {
    Value     int       `json:"value"`
    Timestamp time.Time `json:"timestamp"`
}

// 2. Store events instead of state
func (c *CounterActor) Increment() (*CounterResponse, error) {
    event := CounterIncremented{
        Amount:    1,
        Timestamp: time.Now(),
    }
    
    // Append event to event store
    if err := c.appendEvent("incremented", event); err != nil {
        return nil, err
    }
    
    // Compute current state by replaying all events
    currentState, err := c.replayEvents()
    if err != nil {
        return nil, err
    }
    
    return &CounterResponse{Value: currentState.Value}, nil
}

// 3. Replay events to compute current state
func (c *CounterActor) replayEvents() (*CounterState, error) {
    events, err := c.getAllEvents()
    if err != nil {
        return nil, err
    }
    
    state := &CounterState{Value: 0}
    for _, event := range events {
        switch event.Type {
        case "incremented":
            var e CounterIncremented
            json.Unmarshal(event.Data, &e)
            state.Value += e.Amount
        case "set":
            var e CounterSet
            json.Unmarshal(event.Data, &e)
            state.Value = e.Value
        }
    }
    
    return state, nil
}
```

## Summary

This Dapr actors demo uses **state-based persistence** for simplicity and performance. While event sourcing is a powerful pattern, it adds complexity that isn't needed for a basic counter example. The choice between state-based and event-sourced actors depends on your specific requirements for history, auditability, and business logic complexity.